"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xmlRead = exports.xmlWrite = exports.toXmlNode = exports._xmlIterParser = void 0;
const tslib_1 = require("tslib");
const base_1 = require("./base");
const helpers_1 = require("./_internal/helpers");
const events_1 = require("events");
// tslint:disable
const xmlStream = require('xml-flow');
/**
 * Parse XML source to iterator
 * @param param0
 */
function _xmlIterParser({ pattern, source }) {
    return tslib_1.__asyncGenerator(this, arguments, function* _xmlIterParser_1() {
        const parser = xmlStream(source, {
            strict: true
        });
        const data = [];
        let done = false;
        parser.resume();
        parser.on(`tag:${pattern}`, (obj) => {
            data.push(obj);
            if (data.length > 10) {
                source.pause();
            }
        });
        parser.on('end', () => {
            done = true;
        });
        parser.on('close', () => {
            done = true;
        });
        source.on('close', () => {
            done = true;
        });
        source.on('end', () => {
            done = true;
        });
        source.on('error', (err) => {
            throw err;
        });
        while (!done || data.length > 0) {
            const d = data.shift();
            if (!d) {
                yield tslib_1.__await(helpers_1.delay(0));
                source.resume();
                continue;
            }
            yield yield tslib_1.__await(d);
        }
    });
}
exports._xmlIterParser = _xmlIterParser;
function _xmlWriterParser(data, out) {
    return tslib_1.__asyncGenerator(this, arguments, function* _xmlWriterParser_1() {
        var e_1, _a;
        let first = 0;
        let dest = null;
        let loaded = false;
        try {
            for (var data_1 = tslib_1.__asyncValues(data), data_1_1; data_1_1 = yield tslib_1.__await(data_1.next()), !data_1_1.done;) {
                const d = data_1_1.value;
                if (!loaded) {
                    loaded = true;
                    dest = yield tslib_1.__await(out());
                }
                if (first === 0) {
                    dest === null || dest === void 0 ? void 0 : dest.write("<root>");
                }
                const x = xmlStream.toXml(d, {
                    indent: "\t"
                });
                dest === null || dest === void 0 ? void 0 : dest.write(`\r\n${x}`);
                first++;
                yield yield tslib_1.__await(d);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) yield tslib_1.__await(_a.call(data_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (first !== 0) {
            dest === null || dest === void 0 ? void 0 : dest.write("\n</root>\n");
        }
        dest === null || dest === void 0 ? void 0 : dest.end();
    });
}
function toXmlNode(nodeFn) {
    return (data) => {
        return nodeFn(data);
    };
}
exports.toXmlNode = toXmlNode;
function xmlWrite(data, out) {
    if (arguments.length === 1) {
        if (!(typeof data === 'string' || data instanceof events_1.EventEmitter)) {
            throw new Error("Impossible combination");
        }
        return (d) => {
            return base_1.IX.from(_xmlWriterParser(d, base_1.outputToWriteStream(data)));
        };
    }
    if (typeof data === 'string' || data instanceof events_1.EventEmitter) {
        throw new Error("Impossible combination");
    }
    if (!out) {
        throw new Error("Expected to receive output parameter but got undefined");
    }
    return base_1.IX.from(_xmlWriterParser(data, base_1.outputToWriteStream(out)));
}
exports.xmlWrite = xmlWrite;
function xmlRead(source, options) {
    return base_1.IX.from(_xmlIterParser({
        pattern: options.pattern,
        source: base_1.sourceToReadStream(source)
    }));
}
exports.xmlRead = xmlRead;
