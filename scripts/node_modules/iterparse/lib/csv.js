"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.csvWrite = exports.csvRead = void 0;
const tslib_1 = require("tslib");
const base_1 = require("./base");
const Papa = tslib_1.__importStar(require("papaparse"));
const helpers_1 = require("./_internal/helpers");
const events_1 = require("events");
function _csvIterParser(source, options) {
    return tslib_1.__asyncGenerator(this, arguments, function* _csvIterParser_1() {
        let items = [];
        let done = false;
        Papa.parse(base_1.sourceToReadStream(source), Object.assign({ header: true, step: (result) => {
                if (items.length === 10) {
                    source.pause();
                }
                if (Array.isArray(result.data)) {
                    items.push(...result.data);
                }
                else {
                    items.push(result.data);
                }
            }, complete: () => {
                done = true;
            } }, options));
        while (!done || items.length >= 0) {
            const d = items.shift();
            if (!d) {
                yield tslib_1.__await(helpers_1.delay(0));
                if (done && items.length === 0) {
                    return yield tslib_1.__await(void 0);
                }
                if (!done) {
                    source.resume();
                }
                continue;
            }
            yield yield tslib_1.__await(d);
        }
    });
}
function csvRead(source, options) {
    return base_1.IX.from(_csvIterParser(base_1.sourceToReadStream(source), options));
}
exports.csvRead = csvRead;
function _csvIterWriter(data, out, options) {
    return tslib_1.__asyncGenerator(this, arguments, function* _csvIterWriter_1() {
        var e_1, _a;
        let items = [];
        let chunk = 0;
        let dest = null;
        let loaded = false;
        try {
            for (var data_1 = tslib_1.__asyncValues(data), data_1_1; data_1_1 = yield tslib_1.__await(data_1.next()), !data_1_1.done;) {
                const d = data_1_1.value;
                if (!loaded) {
                    loaded = true;
                    dest = yield tslib_1.__await(out());
                }
                yield yield tslib_1.__await(d);
                if (items.length < 10) {
                    items.push(d);
                }
                const csv = Papa.unparse(items, Object.assign({ header: chunk === 0 }, options));
                items = [];
                chunk++;
                dest === null || dest === void 0 ? void 0 : dest.write(`${csv}\r\n`);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) yield tslib_1.__await(_a.call(data_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (items.length !== 0) {
            const csv = Papa.unparse(items, Object.assign({ header: chunk === 0 }, options));
            dest === null || dest === void 0 ? void 0 : dest.write(csv);
        }
        dest === null || dest === void 0 ? void 0 : dest.end();
    });
}
function csvWrite(data, out) {
    if (arguments.length === 1) {
        if (!(typeof data === 'string' || data instanceof events_1.EventEmitter)) {
            throw new Error("Impossible combination");
        }
        const fn = (d) => {
            return base_1.IX.from(_csvIterWriter(d, base_1.outputToWriteStream(data)));
        };
        return fn;
    }
    if (typeof data === 'string' || data instanceof events_1.EventEmitter) {
        throw new Error("Impossible combination");
    }
    if (!out) {
        throw new Error("Expected to receive output parameter but got undefined");
    }
    return base_1.IX.from(_csvIterWriter(data, base_1.outputToWriteStream(out)));
}
exports.csvWrite = csvWrite;
